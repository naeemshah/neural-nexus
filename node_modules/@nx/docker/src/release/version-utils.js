"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDockerVersionPath = void 0;
exports.handleDockerVersion = handleDockerVersion;
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const path_1 = require("path");
const enquirer_1 = require("enquirer");
const devkit_1 = require("@nx/devkit");
const version_pattern_utils_1 = require("./version-pattern-utils");
const DEFAULT_VERSION_SCHEMES = {
    production: '{currentDate|YYMM.DD}.{shortCommitSha}',
    hotfix: '{currentDate|YYMM.DD}.{shortCommitSha}-hotfix',
};
const getDockerVersionPath = (workspaceRoot, projectRoot) => {
    return (0, path_1.join)(workspaceRoot, 'tmp', projectRoot, '.docker-version');
};
exports.getDockerVersionPath = getDockerVersionPath;
async function handleDockerVersion(workspaceRoot, projectGraphNode, finalConfigForProject, dockerVersionScheme, dockerVersion, versionActionsVersion) {
    // If the full docker image reference is provided, use it directly
    const nxDockerImageRefEnvOverride = process.env.NX_DOCKER_IMAGE_REF?.trim() || undefined;
    // If an explicit dockerVersion is provided, use it directly
    let newVersion;
    if (!nxDockerImageRefEnvOverride) {
        if (dockerVersion) {
            newVersion = dockerVersion;
        }
        else {
            const availableVersionSchemes = finalConfigForProject.dockerOptions.versionSchemes ??
                DEFAULT_VERSION_SCHEMES;
            const versionScheme = dockerVersionScheme && dockerVersionScheme in availableVersionSchemes
                ? dockerVersionScheme
                : Object.keys(availableVersionSchemes).length === 1
                    ? Object.keys(availableVersionSchemes)[0]
                    : await promptForNewVersion(availableVersionSchemes, projectGraphNode.name);
            newVersion = calculateNewVersion(projectGraphNode.name, versionScheme, availableVersionSchemes, versionActionsVersion);
        }
    }
    const logs = updateProjectVersion(newVersion, nxDockerImageRefEnvOverride, workspaceRoot, projectGraphNode.data.root, finalConfigForProject.dockerOptions.repositoryName, finalConfigForProject.dockerOptions.registryUrl);
    return {
        newVersion: newVersion || process.env.NX_DOCKER_IMAGE_REF?.split(':')[1] || null,
        logs,
    };
}
async function promptForNewVersion(versionSchemes, projectName) {
    const { versionScheme } = await (0, enquirer_1.prompt)({
        name: 'versionScheme',
        type: 'select',
        message: `What type of docker release would you like to make for project "${projectName}"?`,
        choices: Object.keys(versionSchemes).map((vs) => ({
            name: vs,
            message: vs,
            value: vs,
            hint: (0, version_pattern_utils_1.interpolateVersionPattern)(versionSchemes[vs], { projectName }),
        })),
    });
    return versionScheme;
}
function calculateNewVersion(projectName, versionScheme, versionSchemes, versionActionsVersion) {
    if (!(versionScheme in versionSchemes)) {
        throw new Error(`Could not find version scheme '${versionScheme}'. Available options are: ${Object.keys(versionSchemes).join(', ')}.`);
    }
    return (0, version_pattern_utils_1.interpolateVersionPattern)(versionSchemes[versionScheme], {
        projectName,
        versionActionsVersion,
    });
}
function updateProjectVersion(newVersion, nxDockerImageRefEnvOverride, workspaceRoot, projectRoot, repositoryName, registry) {
    const isDryRun = process.env.NX_DRY_RUN && process.env.NX_DRY_RUN !== 'false';
    const imageRef = getDefaultImageReference(projectRoot);
    const newImageRef = getImageReference(projectRoot, repositoryName, registry);
    const fullImageRef = nxDockerImageRefEnvOverride ?? `${newImageRef}:${newVersion}`;
    if (!isDryRun) {
        (0, child_process_1.execSync)(`docker tag ${imageRef} ${fullImageRef}`);
    }
    const logs = isDryRun
        ? [`Image would be tagged with ${fullImageRef} but dry run is enabled.`]
        : [`Image tagged with ${fullImageRef}.`];
    if (isDryRun) {
        logs.push(`No changes were applied as --dry-run is enabled.`);
    }
    else {
        const dockerVersionPath = (0, exports.getDockerVersionPath)(workspaceRoot, projectRoot);
        (0, fs_1.mkdirSync)((0, path_1.dirname)(dockerVersionPath), { recursive: true });
        (0, fs_1.writeFileSync)(dockerVersionPath, fullImageRef);
    }
    return logs;
}
function getImageReference(projectRoot, repositoryName, registry) {
    let imageRef = repositoryName ?? getDefaultImageReference(projectRoot);
    if (registry) {
        imageRef = `${registry}/${imageRef}`;
    }
    return imageRef;
}
function getDefaultImageReference(projectRoot) {
    const root = projectRoot === '.' ? devkit_1.workspaceRoot : projectRoot;
    const normalized = root
        .replace(/^[\\/]/, '')
        .replace(/[\\/\s]+/g, '-')
        .toLowerCase();
    return normalized.length > 128 ? normalized.slice(-128) : normalized;
}
